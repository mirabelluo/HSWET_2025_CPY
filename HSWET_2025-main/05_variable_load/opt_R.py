import numpy as np
import random
import math

def create_bits_matrix(n):
    """
    Create a (2^n x n) matrix where each row is the binary representation (0/1)
    of the mask for n resistors.
    """
    N = 2**n
    masks = np.arange(N, dtype=np.uint32)
    bits = ((masks[:, None] >> np.arange(n)) & 1).astype(np.float64)
    return bits

def cost_function(R, bits, region_min=2.0, region_max=50.0):
    """
    Given resistor values R (an array of length n) and a precomputed bits matrix,
    compute the effective resistance for every combination (using the formula for
    parallel resistors: R_eff = 1/(sum(1/R_i) for each resistor i in the combination)).
    
    Then, filter the effective resistances that lie within [region_min, region_max].
    If fewer than 2 values fall in the region, return a large penalty cost.
    
    Otherwise, compute:
      - The variance of the differences between adjacent (sorted) effective resistances.
      - A penalty term if the effective resistances in the region do not span the full target range.
      
    The total cost is the sum of these two terms. Lower cost means the effective values
    are more evenly spaced (more linear) in the target region.
    """
    n = len(R)
    reciprocals = 1.0 / R
    sum_rec = bits.dot(reciprocals)
    # For mask 0 (no resistor selected) set effective resistance to infinity.
    sum_rec[0] = 0.0  
    eff = np.where(sum_rec == 0, np.inf, 1.0 / sum_rec)
    
    # Filter effective resistances within the desired region.
    valid = (eff >= region_min) & (eff <= region_max)
    eff_region = eff[valid]
    
    # If there are too few points in the region, assign a large penalty.
    if len(eff_region) < 2:
        return 1e6
    
    # Sort the effective resistances in the target region.
    eff_sorted = np.sort(eff_region)
    # Compute differences between consecutive effective resistances.
    diffs = np.diff(eff_sorted)
    mean_diff = np.mean(diffs)
    var_diffs = np.mean((diffs - mean_diff)**2)
    
    # Also penalize if the effective values do not cover the entire desired range.
    range_coverage = eff_sorted[-1] - eff_sorted[0]
    desired_range = region_max - region_min
    range_penalty = (desired_range - range_coverage)**2
    
    cost = var_diffs + range_penalty
    return cost

def optimize_resistors(R_min, R_max, n=16, iterations=50000, region_min=2.0, region_max=50.0):
    """
    Optimize n resistor values (each an integer between R_min and R_max) so that
    the effective resistances generated by their parallel combinations are as linear
    as possible in the region [region_min, region_max].
    
    This function uses simulated annealing:
      - It starts with an initial guess (linearly spaced values between R_min and R_max).
      - At each iteration, it perturbs one resistor by a small integer amount.
      - It accepts the change if it lowers the cost, or with a probability
        exp(-(Δcost)/T) if not, then gradually cools T.
    """
    bits = create_bits_matrix(n)
    
    # Initial guess: linearly spaced resistor values (as floats, then cast/rounded as needed)
    current_R = np.linspace(R_min, R_max, n, dtype=np.int32).astype(np.float64)
    best_R = current_R.copy()
    current_cost = cost_function(current_R, bits, region_min, region_max)
    best_cost = current_cost
    
    T = 1.0       # Initial temperature
    T_min = 1e-6  # Minimum temperature
    alpha = 0.999 # Cooling rate
    
    for it in range(iterations):
        # Create a candidate by perturbing one resistor value.
        candidate_R = current_R.copy()
        idx = random.randint(0, n - 1)
        delta = random.randint(-10, 10)  # small integer change (ohms)
        candidate_R[idx] += delta
        candidate_R[idx] = max(R_min, min(R_max, candidate_R[idx]))
        candidate_R[idx] = round(candidate_R[idx])
        
        candidate_cost = cost_function(candidate_R, bits, region_min, region_max)
        
        # Accept the candidate if it improves cost, or probabilistically if not.
        if candidate_cost < current_cost:
            current_R = candidate_R
            current_cost = candidate_cost
            if candidate_cost < best_cost:
                best_cost = candidate_cost
                best_R = candidate_R
        else:
            if random.random() < math.exp(-(candidate_cost - current_cost) / T):
                current_R = candidate_R
                current_cost = candidate_cost
        
        T = max(T * alpha, T_min)
        
        if it % 1000 == 0:
            print(f"Iteration {it:6d}  Current cost: {current_cost:.6f}  Best cost: {best_cost:.6f}")
    
    return best_R, best_cost

if __name__ == "__main__":
    # Define the allowed resistor range (in ohms).
    R_min_val = 2      # for example, 100 Ω minimum
    R_max_val = 300   # for example, 10 kΩ maximum
    # Define the target effective resistance region.
    region_min = 5.0   # 2 Ω
    region_max = 40.0  # 50 Ω
    
    best_resistors, best_cost = optimize_resistors(R_min_val, R_max_val, n=8,
                                                     iterations=30000,
                                                     region_min=region_min,
                                                     region_max=region_max)
    
    print("\nOptimized resistor values (ohms):")
    print(sorted([float(x) for x in best_resistors.astype(int)]))
    print("Best cost:", best_cost)
